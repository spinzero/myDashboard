{"remainingRequest":"/home/grg/ANGULAR/myDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/text-field.es5.js","dependencies":[{"path":"/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/text-field.es5.js","mtime":499162500000},{"path":"/home/grg/ANGULAR/myDashboard/node_modules/cache-loader/dist/cjs.js","mtime":1535911065030},{"path":"/home/grg/ANGULAR/myDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_cdk_platform,_angular_core,rxjs,_angular_cdk_coercion,rxjs_operators PURE_IMPORTS_END */\nimport { Platform, supportsPassiveEventListeners, PlatformModule } from '@angular/cdk/platform';\nimport { Directive, ElementRef, EventEmitter, Injectable, NgZone, Output, Input, NgModule, defineInjectable, inject } from '@angular/core';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { auditTime, takeUntil } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options to pass to the animationstart listener.\n */\nvar /** @type {?} */ listenerOptions = /*@__PURE__*/ supportsPassiveEventListeners() ? { passive: true } : false;\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/\\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nvar AutofillMonitor = /** @class */ /*@__PURE__*/ (function () {\n    function AutofillMonitor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    AutofillMonitor.prototype.monitor = /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n        function (elementOrRef) {\n            var _this = this;\n            if (!this._platform.isBrowser) {\n                return EMPTY;\n            }\n            var /** @type {?} */ element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n            var /** @type {?} */ info = this._monitoredElements.get(element);\n            if (info) {\n                return info.subject.asObservable();\n            }\n            var /** @type {?} */ result = new Subject();\n            var /** @type {?} */ cssClass = 'cdk-text-field-autofilled';\n            var /** @type {?} */ listener = function (event) {\n                // Animation events fire on initial element render, we check for the presence of the autofill\n                // CSS class to make sure this is a real change in state, not just the initial render before\n                // we fire off events.\n                if (event.animationName === 'cdk-text-field-autofill-start' &&\n                    !element.classList.contains(cssClass)) {\n                    element.classList.add(cssClass);\n                    _this._ngZone.run(function () { return result.next({ target: /** @type {?} */ (event.target), isAutofilled: true }); });\n                }\n                else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                    element.classList.contains(cssClass)) {\n                    element.classList.remove(cssClass);\n                    _this._ngZone.run(function () { return result.next({ target: /** @type {?} */ (event.target), isAutofilled: false }); });\n                }\n            };\n            this._ngZone.runOutsideAngular(function () {\n                element.addEventListener('animationstart', listener, listenerOptions);\n                element.classList.add('cdk-text-field-autofill-monitored');\n            });\n            this._monitoredElements.set(element, {\n                subject: result,\n                unlisten: function () {\n                    element.removeEventListener('animationstart', listener, listenerOptions);\n                }\n            });\n            return result.asObservable();\n        };\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    AutofillMonitor.prototype.stopMonitoring = /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n        function (elementOrRef) {\n            var /** @type {?} */ element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n            var /** @type {?} */ info = this._monitoredElements.get(element);\n            if (info) {\n                info.unlisten();\n                info.subject.complete();\n                element.classList.remove('cdk-text-field-autofill-monitored');\n                element.classList.remove('cdk-text-field-autofilled');\n                this._monitoredElements.delete(element);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    AutofillMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n        };\n    /** @nocollapse */ AutofillMonitor.ngInjectableDef = defineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(inject(Platform), inject(NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\n    return AutofillMonitor;\n}());\n/**\n * A directive that can be used to monitor the autofill state of an input.\n */\nvar CdkAutofill = /** @class */ /*@__PURE__*/ (function () {\n    function CdkAutofill(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /**\n         * Emits when the autofill state of the element changes.\n         */\n        this.cdkAutofill = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._autofillMonitor\n                .monitor(this._elementRef)\n                .subscribe(function (event) { return _this.cdkAutofill.emit(event); });\n        };\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._autofillMonitor.stopMonitoring(this._elementRef);\n        };\n    return CdkAutofill;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nvar CdkTextareaAutosize = /** @class */ /*@__PURE__*/ (function () {\n    function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        this._textareaElement = /** @type {?} */ (this._elementRef.nativeElement);\n    }\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"minRows\", {\n        get: /**\n         * Minimum amount of rows in the textarea.\n         * @return {?}\n         */ function () { return this._minRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._minRows = value;\n            this._setMinHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"maxRows\", {\n        get: /**\n         * Maximum amount of rows in the textarea.\n         * @return {?}\n         */ function () { return this._maxRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._maxRows = value;\n            this._setMaxHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"enabled\", {\n        get: /**\n         * Whether autosizing is enabled or not\n         * @return {?}\n         */ function () { return this._enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            value = coerceBooleanProperty(value);\n            // Only act if the actual value changed. This specifically helps to not run\n            // resizeToFitContent too early (i.e. before ngAfterViewInit)\n            if (this._enabled !== value) {\n                (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMinHeight = /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ minHeight = this.minRows && this._cachedLineHeight ?\n                this.minRows * this._cachedLineHeight + \"px\" : null;\n            if (minHeight) {\n                this._setTextareaStyle('minHeight', minHeight);\n            }\n        };\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMaxHeight = /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ maxHeight = this.maxRows && this._cachedLineHeight ?\n                this.maxRows * this._cachedLineHeight + \"px\" : null;\n            if (maxHeight) {\n                this._setTextareaStyle('maxHeight', maxHeight);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._platform.isBrowser) {\n                // Remember the height which we started with in case autosizing is disabled\n                this._initialHeight = this._textareaElement.style.height;\n                this.resizeToFitContent();\n                this._ngZone.runOutsideAngular(function () {\n                    fromEvent(window, 'resize')\n                        .pipe(auditTime(16), takeUntil(_this._destroyed))\n                        .subscribe(function () { return _this.resizeToFitContent(true); });\n                });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n        };\n    /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setTextareaStyle = /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n        function (property, value) {\n            this._textareaElement.style[property] = value;\n        };\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._cacheTextareaLineHeight = /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n        function () {\n            if (this._cachedLineHeight) {\n                return;\n            }\n            // Use a clone element because we have to override some styles.\n            var /** @type {?} */ textareaClone = /** @type {?} */ (this._textareaElement.cloneNode(false));\n            textareaClone.rows = 1;\n            // Use `position: absolute` so that this doesn't cause a browser layout and use\n            // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n            // would affect the height.\n            textareaClone.style.position = 'absolute';\n            textareaClone.style.visibility = 'hidden';\n            textareaClone.style.border = 'none';\n            textareaClone.style.padding = '0';\n            textareaClone.style.height = '';\n            textareaClone.style.minHeight = '';\n            textareaClone.style.maxHeight = '';\n            // In Firefox it happens that textarea elements are always bigger than the specified amount\n            // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n            // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n            // to hidden. This ensures that there is no invalid calculation of the line height.\n            // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n            textareaClone.style.overflow = 'hidden'; /** @type {?} */\n            ((this._textareaElement.parentNode)).appendChild(textareaClone);\n            this._cachedLineHeight = textareaClone.clientHeight; /** @type {?} */\n            ((this._textareaElement.parentNode)).removeChild(textareaClone);\n            // Min and max heights have to be re-calculated if the cached line height changes\n            this._setMinHeight();\n            this._setMaxHeight();\n        };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (this._platform.isBrowser) {\n                this.resizeToFitContent();\n            }\n        };\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.resizeToFitContent = /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n        function (force) {\n            var _this = this;\n            if (force === void 0) {\n                force = false;\n            }\n            // If autosizing is disabled, just skip everything else\n            if (!this._enabled) {\n                return;\n            }\n            this._cacheTextareaLineHeight();\n            // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n            // in checking the height of the textarea.\n            if (!this._cachedLineHeight) {\n                return;\n            }\n            var /** @type {?} */ textarea = /** @type {?} */ (this._elementRef.nativeElement);\n            var /** @type {?} */ value = textarea.value;\n            // Only resize of the value changed since these calculations can be expensive.\n            if (value === this._previousValue && !force) {\n                return;\n            }\n            var /** @type {?} */ placeholderText = textarea.placeholder;\n            // Reset the textarea height to auto in order to shrink back to its default size.\n            // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n            // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n            // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n            // need to be removed temporarily.\n            textarea.classList.add('cdk-textarea-autosize-measuring');\n            textarea.placeholder = '';\n            // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n            // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n            var /** @type {?} */ height = textarea.scrollHeight - 4;\n            // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n            textarea.style.height = height + \"px\";\n            textarea.classList.remove('cdk-textarea-autosize-measuring');\n            textarea.placeholder = placeholderText;\n            // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n            // We need to re-set the selection in order for it to scroll to the proper position.\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(function () {\n                    return requestAnimationFrame(function () {\n                        var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;\n                        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n                        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n                        // between the time we requested the animation frame and when it was executed.\n                        // Also note that we have to assert that the textarea is focused before we set the\n                        // selection range. Setting the selection range on a non-focused textarea will cause\n                        // it to receive focus on IE and Edge.\n                        if (!_this._destroyed.isStopped && document.activeElement === textarea) {\n                            textarea.setSelectionRange(selectionStart, selectionEnd);\n                        }\n                    });\n                });\n            }\n            this._previousValue = value;\n        };\n    /**\n     * Resets the textarea to it's original size\n     */\n    /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.reset = /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n        function () {\n            // Do not try to change the textarea, if the initialHeight has not been determined yet\n            // This might potentially remove styles when reset() is called before ngAfterViewInit\n            if (this._initialHeight === undefined) {\n                return;\n            }\n            this._textareaElement.style.height = this._initialHeight;\n        };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._noopInputHandler = /**\n     * @return {?}\n     */\n        function () {\n            // no-op handler that ensures we're running change detection on input events.\n        };\n    return CdkTextareaAutosize;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar TextFieldModule = /** @class */ /*@__PURE__*/ (function () {\n    function TextFieldModule() {\n    }\n    return TextFieldModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n\n\n\n",{"version":3,"file":"/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/text-field.es5.js.post-build-optimizer.js","sourceRoot":"","sources":["/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/text-field.es5.js.pre-build-optimizer.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform, supportsPassiveEventListeners, PlatformModule } from '@angular/cdk/platform';\nimport { Directive, ElementRef, EventEmitter, Injectable, NgZone, Output, Input, NgModule, defineInjectable, inject } from '@angular/core';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { auditTime, takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options to pass to the animationstart listener.\n */\nvar /** @type {?} */ listenerOptions = supportsPassiveEventListeners() ? { passive: true } : false;\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/\\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nvar AutofillMonitor = /** @class */ (function () {\n    function AutofillMonitor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    AutofillMonitor.prototype.monitor = /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    function (elementOrRef) {\n        var _this = this;\n        if (!this._platform.isBrowser) {\n            return EMPTY;\n        }\n        var /** @type {?} */ element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n        var /** @type {?} */ info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject.asObservable();\n        }\n        var /** @type {?} */ result = new Subject();\n        var /** @type {?} */ cssClass = 'cdk-text-field-autofilled';\n        var /** @type {?} */ listener = function (event) {\n            // Animation events fire on initial element render, we check for the presence of the autofill\n            // CSS class to make sure this is a real change in state, not just the initial render before\n            // we fire off events.\n            if (event.animationName === 'cdk-text-field-autofill-start' &&\n                !element.classList.contains(cssClass)) {\n                element.classList.add(cssClass);\n                _this._ngZone.run(function () { return result.next({ target: /** @type {?} */ (event.target), isAutofilled: true }); });\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                element.classList.contains(cssClass)) {\n                element.classList.remove(cssClass);\n                _this._ngZone.run(function () { return result.next({ target: /** @type {?} */ (event.target), isAutofilled: false }); });\n            }\n        };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        });\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: function () {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            }\n        });\n        return result.asObservable();\n    };\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    AutofillMonitor.prototype.stopMonitoring = /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    function (elementOrRef) {\n        var /** @type {?} */ element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n        var /** @type {?} */ info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AutofillMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    AutofillMonitor.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    AutofillMonitor.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    /** @nocollapse */ AutofillMonitor.ngInjectableDef = defineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(inject(Platform), inject(NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\n    return AutofillMonitor;\n}());\n/**\n * A directive that can be used to monitor the autofill state of an input.\n */\nvar CdkAutofill = /** @class */ (function () {\n    function CdkAutofill(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /**\n         * Emits when the autofill state of the element changes.\n         */\n        this.cdkAutofill = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._autofillMonitor\n            .monitor(this._elementRef)\n            .subscribe(function (event) { return _this.cdkAutofill.emit(event); });\n    };\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._autofillMonitor.stopMonitoring(this._elementRef);\n    };\n    CdkAutofill.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkAutofill]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkAutofill.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: AutofillMonitor, },\n    ]; };\n    CdkAutofill.propDecorators = {\n        \"cdkAutofill\": [{ type: Output },],\n    };\n    return CdkAutofill;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nvar CdkTextareaAutosize = /** @class */ (function () {\n    function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        this._textareaElement = /** @type {?} */ (this._elementRef.nativeElement);\n    }\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"minRows\", {\n        get: /**\n         * Minimum amount of rows in the textarea.\n         * @return {?}\n         */\n        function () { return this._minRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._minRows = value;\n            this._setMinHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"maxRows\", {\n        get: /**\n         * Maximum amount of rows in the textarea.\n         * @return {?}\n         */\n        function () { return this._maxRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._maxRows = value;\n            this._setMaxHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"enabled\", {\n        get: /**\n         * Whether autosizing is enabled or not\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            value = coerceBooleanProperty(value);\n            // Only act if the actual value changed. This specifically helps to not run\n            // resizeToFitContent too early (i.e. before ngAfterViewInit)\n            if (this._enabled !== value) {\n                (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMinHeight = /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ minHeight = this.minRows && this._cachedLineHeight ?\n            this.minRows * this._cachedLineHeight + \"px\" : null;\n        if (minHeight) {\n            this._setTextareaStyle('minHeight', minHeight);\n        }\n    };\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMaxHeight = /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ maxHeight = this.maxRows && this._cachedLineHeight ?\n            this.maxRows * this._cachedLineHeight + \"px\" : null;\n        if (maxHeight) {\n            this._setTextareaStyle('maxHeight', maxHeight);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular(function () {\n                fromEvent(window, 'resize')\n                    .pipe(auditTime(16), takeUntil(_this._destroyed))\n                    .subscribe(function () { return _this.resizeToFitContent(true); });\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setTextareaStyle = /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    function (property, value) {\n        this._textareaElement.style[property] = value;\n    };\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._cacheTextareaLineHeight = /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n    function () {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        var /** @type {?} */ textareaClone = /** @type {?} */ (this._textareaElement.cloneNode(false));\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden'; /** @type {?} */\n        ((this._textareaElement.parentNode)).appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight; /** @type {?} */\n        ((this._textareaElement.parentNode)).removeChild(textareaClone);\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    };\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.resizeToFitContent = /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    function (force) {\n        var _this = this;\n        if (force === void 0) { force = false; }\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        var /** @type {?} */ textarea = /** @type {?} */ (this._elementRef.nativeElement);\n        var /** @type {?} */ value = textarea.value;\n        // Only resize of the value changed since these calculations can be expensive.\n        if (value === this._previousValue && !force) {\n            return;\n        }\n        var /** @type {?} */ placeholderText = textarea.placeholder;\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n        // need to be removed temporarily.\n        textarea.classList.add('cdk-textarea-autosize-measuring');\n        textarea.placeholder = '';\n        // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n        // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        var /** @type {?} */ height = textarea.scrollHeight - 4;\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = height + \"px\";\n        textarea.classList.remove('cdk-textarea-autosize-measuring');\n        textarea.placeholder = placeholderText;\n        // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n        // We need to re-set the selection in order for it to scroll to the proper position.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                return requestAnimationFrame(function () {\n                    var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;\n                    // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n                    // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n                    // between the time we requested the animation frame and when it was executed.\n                    // Also note that we have to assert that the textarea is focused before we set the\n                    // selection range. Setting the selection range on a non-focused textarea will cause\n                    // it to receive focus on IE and Edge.\n                    if (!_this._destroyed.isStopped && document.activeElement === textarea) {\n                        textarea.setSelectionRange(selectionStart, selectionEnd);\n                    }\n                });\n            });\n        }\n        this._previousValue = value;\n    };\n    /**\n     * Resets the textarea to it's original size\n     */\n    /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.reset = /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n    function () {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight === undefined) {\n            return;\n        }\n        this._textareaElement.style.height = this._initialHeight;\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._noopInputHandler = /**\n     * @return {?}\n     */\n    function () {\n        // no-op handler that ensures we're running change detection on input events.\n    };\n    CdkTextareaAutosize.decorators = [\n        { type: Directive, args: [{\n                    selector: 'textarea[cdkTextareaAutosize]',\n                    exportAs: 'cdkTextareaAutosize',\n                    host: {\n                        'class': 'cdk-textarea-autosize',\n                        // Textarea elements that have the directive applied should have a single row by default.\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                        'rows': '1',\n                        '(input)': '_noopInputHandler()',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTextareaAutosize.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    CdkTextareaAutosize.propDecorators = {\n        \"minRows\": [{ type: Input, args: ['cdkAutosizeMinRows',] },],\n        \"maxRows\": [{ type: Input, args: ['cdkAutosizeMaxRows',] },],\n        \"enabled\": [{ type: Input, args: ['cdkTextareaAutosize',] },],\n    };\n    return CdkTextareaAutosize;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar TextFieldModule = /** @class */ (function () {\n    function TextFieldModule() {\n    }\n    TextFieldModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [CdkAutofill, CdkTextareaAutosize],\n                    imports: [PlatformModule],\n                    exports: [CdkAutofill, CdkTextareaAutosize],\n                },] },\n    ];\n    return TextFieldModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n//# sourceMappingURL=text-field.es5.js.map\n"]}]}