{"remainingRequest":"/home/grg/ANGULAR/myDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/a11y.es5.js","dependencies":[{"path":"/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/a11y.es5.js","mtime":499162500000},{"path":"/home/grg/ANGULAR/myDashboard/node_modules/cache-loader/dist/cjs.js","mtime":1535911065030},{"path":"/home/grg/ANGULAR/myDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_common,_angular_core,rxjs,_angular_cdk_keycodes,rxjs_operators,tslib,_angular_cdk_platform,_angular_cdk_coercion,_angular_cdk_observers PURE_IMPORTS_END */\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Inject, Injectable, Optional, SkipSelf, QueryList, Directive, ElementRef, Input, NgZone, InjectionToken, EventEmitter, Output, NgModule, defineInjectable, inject } from '@angular/core';\nimport { Subject, Subscription, of } from 'rxjs';\nimport { UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, TAB, A, Z, ZERO, NINE } from '@angular/cdk/keycodes';\nimport { debounceTime, filter, map, tap, take } from 'rxjs/operators';\nimport { __extends } from 'tslib';\nimport { Platform, supportsPassiveEventListeners, PlatformModule } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ContentObserver, ObserversModule } from '@angular/cdk/observers';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar /** @type {?} */ ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * ID used for the body container where all messages are appended.\n */\nvar /** @type {?} */ MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar /** @type {?} */ CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar /** @type {?} */ CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar /** @type {?} */ nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar /** @type {?} */ messageRegistry = /*@__PURE__*/ new Map();\n/**\n * Container for all registered messages.\n */\nvar /** @type {?} */ messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = /** @class */ /*@__PURE__*/ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n        function (hostElement, message) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            if (!messageRegistry.has(message)) {\n                this._createMessageElement(message);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, message)) {\n                this._addMessageReference(hostElement, message);\n            }\n        };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n        function (hostElement, message) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            if (this._isElementDescribedByMessage(hostElement, message)) {\n                this._removeMessageReference(hostElement, message);\n            }\n            var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\n                this._deleteMessageElement(message);\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n            for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n        function (message) {\n            var /** @type {?} */ messageElement = this._document.createElement('div');\n            messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n            messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n            this._createMessagesContainer(); /** @type {?} */\n            ((messagesContainer)).appendChild(messageElement);\n            messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n        };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n        function (message) {\n            var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n            var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(message);\n        };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n        function () {\n            if (!messagesContainer) {\n                var /** @type {?} */ preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer) {\n                    /** @type {?} */ ((preExistingContainer.parentNode)).removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                messagesContainer.setAttribute('aria-hidden', 'true');\n                messagesContainer.style.display = 'none';\n                this._document.body.appendChild(messagesContainer);\n            }\n        };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n        function () {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n        function (element, message) {\n            var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n        function (element, message) {\n            var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n        function (element, message) {\n            var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n            var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        };\n    /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._canBeDescribed = /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n        function (element, message) {\n            return element.nodeType === this._document.ELEMENT_NODE && message != null &&\n                !!(\"\" + message).trim();\n        };\n    /** @nocollapse */ AriaDescriber.ngInjectableDef = defineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(inject(DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nvar \n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nListKeyManager = /** @class */ /*@__PURE__*/ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = function (item) { return item.disabled; };\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            _items.changes.subscribe(function (newItems) {\n                if (_this._activeItem) {\n                    var /** @type {?} */ itemArray = newItems.toArray();\n                    var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                    if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                        _this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    ListKeyManager.prototype.skipPredicate = /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n        function (predicate) {\n            this._skipPredicateFn = predicate;\n            return this;\n        };\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\n     * @return {?}\n     */\n        function (shouldWrap) {\n            if (shouldWrap === void 0) {\n                shouldWrap = true;\n            }\n            this._wrap = shouldWrap;\n            return this;\n        };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n        function (enabled) {\n            if (enabled === void 0) {\n                enabled = true;\n            }\n            this._vertical = enabled;\n            return this;\n        };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n        function (direction) {\n            this._horizontal = direction;\n            return this;\n        };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n        function (debounceInterval) {\n            var _this = this;\n            if (debounceInterval === void 0) {\n                debounceInterval = 200;\n            }\n            if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n            this._typeaheadSubscription.unsubscribe();\n            // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n            // and convert those letters back into a string. Afterwards find the first item that starts\n            // with that string and select it.\n            this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n                var /** @type {?} */ items = _this._getItemsArray();\n                // Start at 1 because we want to start searching at the item immediately\n                // following the current active item.\n                for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                    var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                    var /** @type {?} */ item = items[index];\n                    if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                        _this.setActiveItem(index);\n                        break;\n                    }\n                }\n                _this._pressedLetters = [];\n            });\n            return this;\n        };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n        function (item) {\n            var /** @type {?} */ previousIndex = this._activeItemIndex;\n            this.updateActiveItem(item);\n            if (this._activeItemIndex !== previousIndex) {\n                this.change.next(this._activeItemIndex);\n            }\n        };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ keyCode = event.keyCode;\n            switch (keyCode) {\n                case TAB:\n                    this.tabOut.next();\n                    return;\n                case DOWN_ARROW:\n                    if (this._vertical) {\n                        this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case UP_ARROW:\n                    if (this._vertical) {\n                        this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case RIGHT_ARROW:\n                    if (this._horizontal === 'ltr') {\n                        this.setNextItemActive();\n                        break;\n                    }\n                    else if (this._horizontal === 'rtl') {\n                        this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case LEFT_ARROW:\n                    if (this._horizontal === 'ltr') {\n                        this.setPreviousItemActive();\n                        break;\n                    }\n                    else if (this._horizontal === 'rtl') {\n                        this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                default:\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                    // Note that we return here, in order to avoid preventing\n                    // the default action of non-navigational keys.\n                    return;\n            }\n            this._pressedLetters = [];\n            event.preventDefault();\n        };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */ function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */ function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n        function () {\n            this._setActiveItemByIndex(0, 1);\n        };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n        function () {\n            this._setActiveItemByIndex(this._items.length - 1, -1);\n        };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n        function () {\n            this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n        };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n        function () {\n            this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                : this._setActiveItemByDelta(-1);\n        };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n        function (item) {\n            var /** @type {?} */ itemArray = this._getItemsArray();\n            var /** @type {?} */ index = typeof item === 'number' ? item : itemArray.indexOf(item);\n            this._activeItemIndex = index;\n            this._activeItem = itemArray[index];\n        };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     * @deprecated Use `updateActiveItem` instead.\n     * @breaking-change 7.0.0\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @deprecated Use `updateActiveItem` instead.\n     * \\@breaking-change 7.0.0\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @deprecated Use `updateActiveItem` instead.\n     * \\@breaking-change 7.0.0\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n        function (index) {\n            this.updateActiveItem(index);\n        };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @return {?}\n     */\n        function (delta) {\n            this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n        };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @return {?}\n     */\n        function (delta) {\n            var /** @type {?} */ items = this._getItemsArray();\n            for (var /** @type {?} */ i = 1; i <= items.length; i++) {\n                var /** @type {?} */ index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!this._skipPredicateFn(item)) {\n                    this.setActiveItem(index);\n                    return;\n                }\n            }\n        };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @return {?}\n     */\n        function (delta) {\n            this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n        };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @return {?}\n     */\n        function (index, fallbackDelta) {\n            var /** @type {?} */ items = this._getItemsArray();\n            if (!items[index]) {\n                return;\n            }\n            while (this._skipPredicateFn(items[index])) {\n                index += fallbackDelta;\n                if (!items[index]) {\n                    return;\n                }\n            }\n            this.setActiveItem(index);\n        };\n    /**\n     * Returns the items as an array.\n     * @return {?}\n     */\n    ListKeyManager.prototype._getItemsArray = /**\n     * Returns the items as an array.\n     * @return {?}\n     */\n        function () {\n            return this._items instanceof QueryList ? this._items.toArray() : this._items;\n        };\n    return ListKeyManager;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @template T\n */\nvar /**\n * @template T\n */ ActiveDescendantKeyManager = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            if (this.activeItem) {\n                this.activeItem.setInactiveStyles();\n            }\n            _super.prototype.setActiveItem.call(this, index);\n            if (this.activeItem) {\n                this.activeItem.setActiveStyles();\n            }\n        };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @template T\n */\nvar /**\n * @template T\n */ FocusKeyManager = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n        function (origin) {\n            this._origin = origin;\n            return this;\n        };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n        function (item) {\n            _super.prototype.setActiveItem.call(this, item);\n            if (this.activeItem) {\n                this.activeItem.focus(this._origin);\n            }\n        };\n    return FocusKeyManager;\n}(ListKeyManager));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = /** @class */ /*@__PURE__*/ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n        function (element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n        function (element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n        function (element) {\n            // Nothing is tabbable on the the server ðŸ˜Ž\n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                    return false;\n                }\n                // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n            var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe') {\n                // The frames may be tabbable depending on content, but it's not possibly to reliably\n                // investigate the content of the frames.\n                return false;\n            }\n            if (nodeName === 'audio') {\n                if (!element.hasAttribute('controls')) {\n                    // By default an <audio> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK) {\n                    // In Blink <audio controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'video') {\n                if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                    // In Trident a <video> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK || this._platform.FIREFOX) {\n                    // In Chrome and Firefox <video controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n                // In all Blink and WebKit based browsers <object> elements are never tabbable.\n                return false;\n            }\n            // In iOS the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            return element.tabIndex >= 0;\n        };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n        function (element) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n        };\n    /** @nocollapse */ InteractivityChecker.ngInjectableDef = defineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(inject(Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch ( /** @type {?} */e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && ( /** @type {?} */(element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar /**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */ FocusTrap = /** @class */ /*@__PURE__*/ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) {\n            deferAnchors = false;\n        }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */ function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n        function () {\n            if (this._startAnchor && this._startAnchor.parentNode) {\n                this._startAnchor.parentNode.removeChild(this._startAnchor);\n            }\n            if (this._endAnchor && this._endAnchor.parentNode) {\n                this._endAnchor.parentNode.removeChild(this._endAnchor);\n            }\n            this._startAnchor = this._endAnchor = null;\n        };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n        function () {\n            var _this = this;\n            // If we're not on the browser, there can be no focus to trap.\n            if (this._hasAttached) {\n                return true;\n            }\n            this._ngZone.runOutsideAngular(function () {\n                if (!_this._startAnchor) {\n                    _this._startAnchor = _this._createAnchor(); /** @type {?} */\n                    ((_this._startAnchor)).addEventListener('focus', function () { return _this.focusLastTabbableElement(); });\n                }\n                if (!_this._endAnchor) {\n                    _this._endAnchor = _this._createAnchor(); /** @type {?} */\n                    ((_this._endAnchor)).addEventListener('focus', function () { return _this.focusFirstTabbableElement(); });\n                }\n            });\n            if (this._element.parentNode) {\n                this._element.parentNode.insertBefore(/** @type {?} */ ((this._startAnchor)), this._element);\n                this._element.parentNode.insertBefore(/** @type {?} */ ((this._endAnchor)), this._element.nextSibling);\n                this._hasAttached = true;\n            }\n            return this._hasAttached;\n        };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n        function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n            });\n        };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n        function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n            });\n        };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n        function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n            });\n        };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n        function (bound) {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n                (\"[cdkFocusRegion\" + bound + \"], \") +\n                (\"[cdk-focus-\" + bound + \"]\")));\n            for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n                // @breaking-change 7.0.0\n                if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated \") +\n                        \"attribute will be removed in 7.0.0.\", markers[i]);\n                }\n                else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated attribute \") +\n                        \"will be removed in 7.0.0.\", markers[i]);\n                }\n            }\n            if (bound == 'start') {\n                return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n            }\n            return markers.length ?\n                markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n        };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n        function () {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n                \"[cdkFocusInitial]\"));\n            if (redirectToElement) {\n                // @breaking-change 7.0.0\n                if (redirectToElement.hasAttribute(\"cdk-focus-initial\")) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', \" +\n                        \"use 'cdkFocusInitial' instead. The deprecated attribute \" +\n                        \"will be removed in 7.0.0\", redirectToElement);\n                }\n                redirectToElement.focus();\n                return true;\n            }\n            return this.focusFirstTabbableElement();\n        };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n        function () {\n            var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n        function () {\n            var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n    /**\n     * Checks whether the focus trap has successfuly been attached.\n     */\n    /**\n     * Checks whether the focus trap has successfuly been attached.\n     * @return {?}\n     */\n    FocusTrap.prototype.hasAttached = /**\n     * Checks whether the focus trap has successfuly been attached.\n     * @return {?}\n     */\n        function () {\n            return this._hasAttached;\n        };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n        function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n            // back to `childNodes` which includes text nodes, comments etc.\n            var /** @type {?} */ children = root.children || root.childNodes;\n            for (var /** @type {?} */ i = 0; i < children.length; i++) {\n                var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n        function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in reverse DOM order.\n            var /** @type {?} */ children = root.children || root.childNodes;\n            for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n                var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ anchor = this._document.createElement('div');\n            anchor.tabIndex = this._enabled ? 0 : -1;\n            anchor.classList.add('cdk-visually-hidden');\n            anchor.classList.add('cdk-focus-trap-anchor');\n            return anchor;\n        };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            if (this._ngZone.isStable) {\n                fn();\n            }\n            else {\n                this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n            }\n        };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = /** @class */ /*@__PURE__*/ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n        function (element, deferCaptureElements) {\n            if (deferCaptureElements === void 0) {\n                deferCaptureElements = false;\n            }\n            return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        };\n    /** @nocollapse */ FocusTrapFactory.ngInjectableDef = defineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(inject(InteractivityChecker), inject(NgZone), inject(DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = /** @class */ /*@__PURE__*/ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */ function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */ function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n                this.focusTrap.focusInitialElementWhenReady();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        };\n    return CdkTrapFocus;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// The token for the live announcer element is defined in a separate file from LiveAnnouncer\n// as a workaround for https://github.com/angular/angular/issues/22559\nvar /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = /*@__PURE__*/ new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LiveAnnouncer = /** @class */ /*@__PURE__*/ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        // We inject the live element and document as `any` because the constructor signature cannot\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n        // a class decorator causes TypeScript to preserve the constructor signature types.\n        this._document = _document;\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n        function (message, politeness) {\n            var _this = this;\n            if (politeness === void 0) {\n                politeness = 'polite';\n            }\n            this._liveElement.textContent = '';\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return new Promise(function (resolve) {\n                setTimeout(function () {\n                    _this._liveElement.textContent = message;\n                    resolve();\n                }, 100);\n            });\n        };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ elementClass = 'cdk-live-announcer-element';\n            var /** @type {?} */ previousElements = this._document.getElementsByClassName(elementClass);\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (var /** @type {?} */ i = 0; i < previousElements.length; i++) {\n                /** @type {?} */ ((previousElements[i].parentNode)).removeChild(previousElements[i]);\n            }\n            var /** @type {?} */ liveEl = this._document.createElement('div');\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        };\n    /** @nocollapse */ LiveAnnouncer.ngInjectableDef = defineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), inject(DOCUMENT)); }, token: LiveAnnouncer, providedIn: \"root\" });\n    return LiveAnnouncer;\n}());\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nvar CdkAriaLive = /** @class */ /*@__PURE__*/ (function () {\n    function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n        this._elementRef = _elementRef;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._contentObserver = _contentObserver;\n        this._ngZone = _ngZone;\n        this._politeness = 'off';\n    }\n    Object.defineProperty(CdkAriaLive.prototype, \"politeness\", {\n        get: /**\n         * The aria-live politeness level to use when announcing messages.\n         * @return {?}\n         */ function () { return this._politeness; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var _this = this;\n            this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\n            if (this._politeness === 'off') {\n                if (this._subscription) {\n                    this._subscription.unsubscribe();\n                    this._subscription = null;\n                }\n            }\n            else if (!this._subscription) {\n                this._subscription = this._ngZone.runOutsideAngular(function () {\n                    return _this._contentObserver\n                        .observe(_this._elementRef)\n                        .subscribe(function () {\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                        var /** @type {?} */ element = _this._elementRef.nativeElement;\n                        _this._liveAnnouncer.announce(element.textContent, _this._politeness);\n                    });\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkAriaLive.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        };\n    return CdkAriaLive;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), LiveAnnouncer],\n        [/*@__PURE__*/ new Optional(), /*@__PURE__*/ new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar /** @type {?} */ TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = /** @class */ /*@__PURE__*/ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n        function (element, checkChildren) {\n            var _this = this;\n            if (checkChildren === void 0) {\n                checkChildren = false;\n            }\n            // Do nothing if we're not on the browser platform.\n            if (!this._platform.isBrowser) {\n                return of(null);\n            }\n            // Check if we're already monitoring this element.\n            if (this._elementInfo.has(element)) {\n                var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n                ((cachedInfo)).checkChildren = checkChildren;\n                return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n            }\n            // Create monitored element info.\n            var /** @type {?} */ info = {\n                unlisten: function () { },\n                checkChildren: checkChildren,\n                subject: new Subject()\n            };\n            this._elementInfo.set(element, info);\n            this._incrementMonitoredElementCount();\n            // Start listening. We need to listen in capture phase since focus events don't bubble.\n            var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n            var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n            this._ngZone.runOutsideAngular(function () {\n                element.addEventListener('focus', focusListener, true);\n                element.addEventListener('blur', blurListener, true);\n            });\n            // Create an unlisten function for later.\n            info.unlisten = function () {\n                element.removeEventListener('focus', focusListener, true);\n                element.removeEventListener('blur', blurListener, true);\n            };\n            return info.subject.asObservable();\n        };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n        function (element) {\n            var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n            if (elementInfo) {\n                elementInfo.unlisten();\n                elementInfo.subject.complete();\n                this._setClasses(element);\n                this._elementInfo.delete(element);\n                this._decrementMonitoredElementCount();\n            }\n        };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element Element to focus.\n     * @param {?} origin Focus origin.\n     * @param {?=} options Options that can be used to configure the focus behavior.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element Element to focus.\n     * @param {?} origin Focus origin.\n     * @param {?=} options Options that can be used to configure the focus behavior.\n     * @return {?}\n     */\n        function (element, origin, options) {\n            this._setOriginForCurrentEventQueue(origin);\n            // `focus` isn't available on the server\n            if (typeof element.focus === 'function') {\n                // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n                ( /** @type {?} */(element)).focus(options);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n        };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Do nothing if we're not on the browser platform.\n            if (!this._platform.isBrowser) {\n                return;\n            }\n            // On keydown record the origin and clear any touch event that may be in progress.\n            var /** @type {?} */ documentKeydownListener = function () {\n                _this._lastTouchTarget = null;\n                _this._setOriginForCurrentEventQueue('keyboard');\n            };\n            // On mousedown record the origin only if there is not touch target, since a mousedown can\n            // happen as a result of a touch event.\n            var /** @type {?} */ documentMousedownListener = function () {\n                if (!_this._lastTouchTarget) {\n                    _this._setOriginForCurrentEventQueue('mouse');\n                }\n            };\n            // When the touchstart event fires the focus event is not yet in the event queue. This means\n            // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n            // see if a focus happens.\n            var /** @type {?} */ documentTouchstartListener = function (event) {\n                if (_this._touchTimeoutId != null) {\n                    clearTimeout(_this._touchTimeoutId);\n                }\n                _this._lastTouchTarget = event.target;\n                _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n            };\n            // Make a note of when the window regains focus, so we can restore the origin info for the\n            // focused element.\n            var /** @type {?} */ windowFocusListener = function () {\n                _this._windowFocused = true;\n                _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });\n            };\n            // Note: we listen to events in the capture phase so we can detect them even if the user stops\n            // propagation.\n            this._ngZone.runOutsideAngular(function () {\n                document.addEventListener('keydown', documentKeydownListener, true);\n                document.addEventListener('mousedown', documentMousedownListener, true);\n                document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? ( /** @type {?} */({ passive: true, capture: true })) : true);\n                window.addEventListener('focus', windowFocusListener);\n            });\n            this._unregisterGlobalListeners = function () {\n                document.removeEventListener('keydown', documentKeydownListener, true);\n                document.removeEventListener('mousedown', documentMousedownListener, true);\n                document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? ( /** @type {?} */({ passive: true, capture: true })) : true);\n                window.removeEventListener('focus', windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(_this._windowFocusTimeoutId);\n                clearTimeout(_this._touchTimeoutId);\n                clearTimeout(_this._originTimeoutId);\n            };\n        };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n        function (element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n        function (element, origin) {\n            var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n            if (elementInfo) {\n                this._toggleClass(element, 'cdk-focused', !!origin);\n                this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n                this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n                this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n                this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n            }\n        };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n        function (origin) {\n            var _this = this;\n            this._ngZone.runOutsideAngular(function () {\n                _this._origin = origin;\n                // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                // tick after the interaction event fired. To ensure the focus origin is always correct,\n                // the focus origin will be determined at the beginning of the next tick.\n                // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                // tick after the interaction event fired. To ensure the focus origin is always correct,\n                // the focus origin will be determined at the beginning of the next tick.\n                _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);\n            });\n        };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n        function (event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            var /** @type {?} */ focusTarget = event.target;\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n        function (event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n                return;\n            }\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            var /** @type {?} */ origin = this._origin;\n            if (!origin) {\n                if (this._windowFocused && this._lastFocusOrigin) {\n                    origin = this._lastFocusOrigin;\n                }\n                else if (this._wasCausedByTouch(event)) {\n                    origin = 'touch';\n                }\n                else {\n                    origin = 'program';\n                }\n            }\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n        function (event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        };\n    /**\n     * @param {?} subject\n     * @param {?} origin\n     * @return {?}\n     */\n    FocusMonitor.prototype._emitOrigin = /**\n     * @param {?} subject\n     * @param {?} origin\n     * @return {?}\n     */\n        function (subject, origin) {\n            this._ngZone.run(function () { return subject.next(origin); });\n        };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n        function () {\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount == 1) {\n                this._registerGlobalListeners();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n        function () {\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                this._unregisterGlobalListeners();\n                this._unregisterGlobalListeners = function () { };\n            }\n        };\n    /** @nocollapse */ FocusMonitor.ngInjectableDef = defineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(inject(NgZone), inject(Platform)); }, token: FocusMonitor, providedIn: \"root\" });\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = /** @class */ /*@__PURE__*/ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n            this._monitorSubscription.unsubscribe();\n        };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar A11yModule = /** @class */ /*@__PURE__*/ (function () {\n    function A11yModule() {\n    }\n    return A11yModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, CdkTrapFocus, InteractivityChecker, LiveAnnouncer, CdkAriaLive, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\n\n\n\n",{"version":3,"file":"/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/a11y.es5.js.post-build-optimizer.js","sourceRoot":"","sources":["/home/grg/ANGULAR/myDashboard/node_modules/@angular/cdk/esm5/a11y.es5.js.pre-build-optimizer.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Inject, Injectable, Optional, SkipSelf, QueryList, Directive, ElementRef, Input, NgZone, InjectionToken, EventEmitter, Output, NgModule, defineInjectable, inject } from '@angular/core';\nimport { Subject, Subscription, of } from 'rxjs';\nimport { UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, TAB, A, Z, ZERO, NINE } from '@angular/cdk/keycodes';\nimport { debounceTime, filter, map, tap, take } from 'rxjs/operators';\nimport { __extends } from 'tslib';\nimport { Platform, supportsPassiveEventListeners, PlatformModule } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ContentObserver, ObserversModule } from '@angular/cdk/observers';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar /** @type {?} */ ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * ID used for the body container where all messages are appended.\n */\nvar /** @type {?} */ MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar /** @type {?} */ CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar /** @type {?} */ CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar /** @type {?} */ nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar /** @type {?} */ messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar /** @type {?} */ messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        this._createMessagesContainer(); /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        if (!messagesContainer) {\n            var /** @type {?} */ preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n            // When going from the server to the client, we may end up in a situation where there's\n            // already a container on the page, but we don't have a reference to it. Clear the\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\n            // container, should be slightly faster.\n            if (preExistingContainer) {\n                /** @type {?} */ ((preExistingContainer.parentNode)).removeChild(preExistingContainer);\n            }\n            messagesContainer = this._document.createElement('div');\n            messagesContainer.id = MESSAGES_CONTAINER_ID;\n            messagesContainer.setAttribute('aria-hidden', 'true');\n            messagesContainer.style.display = 'none';\n            this._document.body.appendChild(messagesContainer);\n        }\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._canBeDescribed = /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        return element.nodeType === this._document.ELEMENT_NODE && message != null &&\n            !!(\"\" + message).trim();\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    /** @nocollapse */ AriaDescriber.ngInjectableDef = defineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(inject(DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nvar  \n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = function (item) { return item.disabled; };\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            _items.changes.subscribe(function (newItems) {\n                if (_this._activeItem) {\n                    var /** @type {?} */ itemArray = newItems.toArray();\n                    var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                    if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                        _this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    ListKeyManager.prototype.skipPredicate = /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    function (predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    };\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\n     * @return {?}\n     */\n    function (shouldWrap) {\n        if (shouldWrap === void 0) { shouldWrap = true; }\n        this._wrap = shouldWrap;\n        return this;\n    };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        this._vertical = enabled;\n        return this;\n    };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    function (direction) {\n        this._horizontal = direction;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this.updateActiveItem(item);\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        var /** @type {?} */ itemArray = this._getItemsArray();\n        var /** @type {?} */ index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        this._activeItemIndex = index;\n        this._activeItem = itemArray[index];\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     * @deprecated Use `updateActiveItem` instead.\n     * @breaking-change 7.0.0\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @deprecated Use `updateActiveItem` instead.\n     * \\@breaking-change 7.0.0\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @deprecated Use `updateActiveItem` instead.\n     * \\@breaking-change 7.0.0\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this.updateActiveItem(index);\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @return {?}\n     */\n    function (delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @return {?}\n     */\n    function (delta) {\n        var /** @type {?} */ items = this._getItemsArray();\n        for (var /** @type {?} */ i = 1; i <= items.length; i++) {\n            var /** @type {?} */ index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            var /** @type {?} */ item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @return {?}\n     */\n    function (delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @return {?}\n     */\n    function (index, fallbackDelta) {\n        var /** @type {?} */ items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    /**\n     * Returns the items as an array.\n     * @return {?}\n     */\n    ListKeyManager.prototype._getItemsArray = /**\n     * Returns the items as an array.\n     * @return {?}\n     */\n    function () {\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @template T\n */\nvar  /**\n * @template T\n */\nActiveDescendantKeyManager = /** @class */ (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @template T\n */\nvar  /**\n * @template T\n */\nFocusKeyManager = /** @class */ (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin;\n        return this;\n    };\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        _super.prototype.setActiveItem.call(this, item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server ðŸ˜Ž\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    /** @nocollapse */ InteractivityChecker.ngInjectableDef = defineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(inject(Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch (/** @type {?} */ e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar  /**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nFocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    function () {\n        var _this = this;\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(function () {\n            if (!_this._startAnchor) {\n                _this._startAnchor = _this._createAnchor(); /** @type {?} */\n                ((_this._startAnchor)).addEventListener('focus', function () { return _this.focusLastTabbableElement(); });\n            }\n            if (!_this._endAnchor) {\n                _this._endAnchor = _this._createAnchor(); /** @type {?} */\n                ((_this._endAnchor)).addEventListener('focus', function () { return _this.focusFirstTabbableElement(); });\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(/** @type {?} */ ((this._startAnchor)), this._element);\n            this._element.parentNode.insertBefore(/** @type {?} */ ((this._endAnchor)), this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            // @breaking-change 7.0.0\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"', \" +\n                    (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated \") +\n                    \"attribute will be removed in 7.0.0.\", markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"', \" +\n                    (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated attribute \") +\n                    \"will be removed in 7.0.0.\", markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (redirectToElement) {\n            // @breaking-change 7.0.0\n            if (redirectToElement.hasAttribute(\"cdk-focus-initial\")) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', \" +\n                    \"use 'cdkFocusInitial' instead. The deprecated attribute \" +\n                    \"will be removed in 7.0.0\", redirectToElement);\n            }\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Checks whether the focus trap has successfuly been attached.\n     */\n    /**\n     * Checks whether the focus trap has successfuly been attached.\n     * @return {?}\n     */\n    FocusTrap.prototype.hasAttached = /**\n     * Checks whether the focus trap has successfuly been attached.\n     * @return {?}\n     */\n    function () {\n        return this._hasAttached;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    /** @nocollapse */ FocusTrapFactory.ngInjectableDef = defineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(inject(InteractivityChecker), inject(NgZone), inject(DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: Input, args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// The token for the live announcer element is defined in a separate file from LiveAnnouncer\n// as a workaround for https://github.com/angular/angular/issues/22559\nvar /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        // We inject the live element and document as `any` because the constructor signature cannot\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n        // a class decorator causes TypeScript to preserve the constructor signature types.\n        this._document = _document;\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                _this._liveElement.textContent = message;\n                resolve();\n            }, 100);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ elementClass = 'cdk-live-announcer-element';\n        var /** @type {?} */ previousElements = this._document.getElementsByClassName(elementClass);\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (var /** @type {?} */ i = 0; i < previousElements.length; i++) {\n            /** @type {?} */ ((previousElements[i].parentNode)).removeChild(previousElements[i]);\n        }\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    /** @nocollapse */ LiveAnnouncer.ngInjectableDef = defineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), inject(DOCUMENT)); }, token: LiveAnnouncer, providedIn: \"root\" });\n    return LiveAnnouncer;\n}());\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nvar CdkAriaLive = /** @class */ (function () {\n    function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n        this._elementRef = _elementRef;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._contentObserver = _contentObserver;\n        this._ngZone = _ngZone;\n        this._politeness = 'off';\n    }\n    Object.defineProperty(CdkAriaLive.prototype, \"politeness\", {\n        get: /**\n         * The aria-live politeness level to use when announcing messages.\n         * @return {?}\n         */\n        function () { return this._politeness; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\n            if (this._politeness === 'off') {\n                if (this._subscription) {\n                    this._subscription.unsubscribe();\n                    this._subscription = null;\n                }\n            }\n            else if (!this._subscription) {\n                this._subscription = this._ngZone.runOutsideAngular(function () {\n                    return _this._contentObserver\n                        .observe(_this._elementRef)\n                        .subscribe(function () {\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                        var /** @type {?} */ element = _this._elementRef.nativeElement;\n                        _this._liveAnnouncer.announce(element.textContent, _this._politeness);\n                    });\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkAriaLive.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    };\n    CdkAriaLive.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkAriaLive]',\n                    exportAs: 'cdkAriaLive',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkAriaLive.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: LiveAnnouncer, },\n        { type: ContentObserver, },\n        { type: NgZone, },\n    ]; };\n    CdkAriaLive.propDecorators = {\n        \"politeness\": [{ type: Input, args: ['cdkAriaLive',] },],\n    };\n    return CdkAriaLive;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar /** @type {?} */ TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    function (element, checkChildren) {\n        var _this = this;\n        if (checkChildren === void 0) { checkChildren = false; }\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element Element to focus.\n     * @param {?} origin Focus origin.\n     * @param {?=} options Options that can be used to configure the focus behavior.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element Element to focus.\n     * @param {?} origin Focus origin.\n     * @param {?=} options Options that can be used to configure the focus behavior.\n     * @return {?}\n     */\n    function (element, origin, options) {\n        this._setOriginForCurrentEventQueue(origin);\n        // `focus` isn't available on the server\n        if (typeof element.focus === 'function') {\n            // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n            (/** @type {?} */ (element)).focus(options);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeoutId != null) {\n                clearTimeout(_this._touchTimeoutId);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(_this._windowFocusTimeoutId);\n            clearTimeout(_this._touchTimeoutId);\n            clearTimeout(_this._originTimeoutId);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this._origin = origin;\n            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n            // tick after the interaction event fired. To ensure the focus origin is always correct,\n            // the focus origin will be determined at the beginning of the next tick.\n            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n            // tick after the interaction event fired. To ensure the focus origin is always correct,\n            // the focus origin will be determined at the beginning of the next tick.\n            _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);\n        });\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        var /** @type {?} */ origin = this._origin;\n        if (!origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                origin = 'touch';\n            }\n            else {\n                origin = 'program';\n            }\n        }\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo.subject, origin);\n        this._lastFocusOrigin = origin;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo.subject, null);\n    };\n    /**\n     * @param {?} subject\n     * @param {?} origin\n     * @return {?}\n     */\n    FocusMonitor.prototype._emitOrigin = /**\n     * @param {?} subject\n     * @param {?} origin\n     * @return {?}\n     */\n    function (subject, origin) {\n        this._ngZone.run(function () { return subject.next(origin); });\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    /** @nocollapse */ FocusMonitor.ngInjectableDef = defineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(inject(NgZone), inject(Platform)); }, token: FocusMonitor, providedIn: \"root\" });\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 7.0.0\n */\nvar /** @type {?} */ FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule, ObserversModule],\n                    declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                },] },\n    ];\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, CdkTrapFocus, InteractivityChecker, LiveAnnouncer, CdkAriaLive, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n"]}]}